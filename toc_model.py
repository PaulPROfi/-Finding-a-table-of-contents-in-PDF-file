import re
import numpy as np
from sklearn.ensemble import RandomForestClassifier

class TOCModel:
# =============================================================================
# Простая ML модель для определения оглавлений в тексте
# Использует Random Forest для классификации
# =============================================================================
    
    def __init__(self):
        """Инициализация модели"""
        # Создаем классификатор Random Forest со 100 деревьями
        self.model = RandomForestClassifier(
            n_estimators=100,  # количество деревьев в лесу
            random_state=42    # для воспроизводимости результатов
        )
        self.is_trained = False  # флаг, показывающий обучена ли модель
    
    def extract_features(self, text):
        """
        Извлекает 6 ключевых признаков из текста для определения оглавления
        Аргументы:
            text: текст для анализа
        Возвращает:
            list: список из 6 числовых признаков
        """
        # Приводим текст к нижнему регистру для удобства поиска
        text_lower = text.lower()
        
        # Создаем список для признаков
        features = [
            # 1. ПРИЗНАК: Наличие ключевых слов оглавления
            # Ищем слова 'содержание', 'оглавление', 'contents' в тексте
            # Возвращаем 1 если нашли, 0 если нет
            int(any(word in text_lower for word in ['содержание', 'оглавление', 'contents'])),
            
            # 2. ПРИЗНАК: Количество последовательностей из 4+ точек
            # В оглавлениях часто используют ...... для заполнения пространства
            len(re.findall(r'\.{4,}', text)),  # ищем 4 или более точек подряд
            
            # 3. ПРИЗНАК: Количество строк, заканчивающихся цифрами
            # В оглавлениях номера страниц обычно в конце строк
            len(re.findall(r'\d+\s*$', text, re.MULTILINE)),  # $ - конец строки
            
            # 4. ПРИЗНАК: Средняя длина строки в тексте
            # В оглавлениях строки обычно короче
            np.mean([len(line) for line in text.split('\n') if line.strip()]) if text.strip() else 0,
            # Разбиваем текст на строки, убираем пустые, считаем среднюю длину
            
            # 5. ПРИЗНАК: Наличие римских цифр
            # В оглавлениях часто используют I, II, III, IV и т.д.
            int(bool(re.search(r'\b[IVX]+\.?\b', text))),  # \b - границы слова
            
            # 6. ПРИЗНАК: Наличие указаний на главы/разделы
            # Ищем паттерны типа "Глава 1", "Раздел 2", "Chapter 3"
            int(bool(re.search(r'(глава|раздел|chapter)\s+\d', text_lower)))
        ]
        
        return features
    
    def create_training_data(self):
        """
        Создает тренировочные данные из примеров оглавлений и обычных текстов
        
        Возвращает:
            tuple: (X, y) где X - матрица признаков, y - вектор меток
        """
        # ПРИМЕРЫ ОГЛАВЛЕНИЙ (положительные примеры, метка 1)
        toc_examples = [
            "Содержание\nВведение ........ 1\nГлава 1 ........ 5\nГлава 2 ........ 10",
            "Оглавление\nРаздел I ....... 3\nРаздел II ...... 8\nРаздел III ..... 12",
            "Contents\nChapter 1 ..... 2\nChapter 2 ..... 10\nChapter 3 ..... 15",
            "СОДЕРЖАНИЕ\n1. Введение .................. 3\n2. Основы .................... 7",
            "ОГЛАВЛЕНИЕ\nI. Начало ............... 1\nII. Основная часть ...... 5\nIII. Заключение ....... 10"
        ]
        
        # ПРИМЕРЫ ОБЫЧНОГО ТЕКСТА (отрицательные примеры, метка 0)
        normal_examples = [
            "Введение в программирование. Программирование это искусство создания программ.",
            "Глава 1. Основы Python. Python современный язык программирования с простым синтаксисом.",
            "Алгоритмы и структуры данных. Сортировка пузырьком простой метод сортировки массивов.",
            "В этой главе мы рассмотрим основные принципы объектно-ориентированного программирования.",
            "Для начала работы с языком Python необходимо установить интерпретатор и настроить среду разработки."
        ]
        
        X = []  # список для признаков
        y = []  # список для меток (0 или 1)
        
        # ОБРАБАТЫВАЕМ ПРИМЕРЫ ОГЛАВЛЕНИЙ
        for example in toc_examples:
            features = self.extract_features(example)  # извлекаем признаки
            X.append(features)  # добавляем признаки в X
            y.append(1)  # добавляем метку 1 (оглавление)
        
        # ОБРАБАТЫВАЕМ ПРИМЕРЫ ОБЫЧНОГО ТЕКСТА
        for example in normal_examples:
            features = self.extract_features(example)  # извлекаем признаки
            X.append(features)  # добавляем признаки в X
            y.append(0)  # добавляем метку 0 (не оглавление)
        
        # Преобразуем в numpy массивы для работы с sklearn
        return np.array(X), np.array(y)
    
    def train(self):
        """Обучает модель на тренировочных данных"""
        X, y = self.create_training_data()
        
        self.model.fit(X, y)  # обучаем модель
        
        self.is_trained = True
    
    def predict(self, text):
        """
        Предсказывает, является ли текст оглавлением
        Аргументы:
            text (str): текст для анализа
        Возвращает:
            tuple: (is_toc, confidence) 
                   is_toc - True если оглавление, False если нет
                   confidence - уверенность модели (0-1)
        """
        # Если модель не обучена, обучаем ее
        if not self.is_trained:
            self.train()
        
        # Извлекаем признаки из текста
        features = self.extract_features(text)
        
        # Делаем предсказание
        prediction = self.model.predict([features])[0]  # predict возвращает массив
        probability = self.model.predict_proba([features])[0].max()  # максимальная вероятность
        
        # prediction = 1 (оглавление) или 0 (не оглавление)
        # преобразуем в boolean и возвращаем с уверенностью
        return bool(prediction), probability